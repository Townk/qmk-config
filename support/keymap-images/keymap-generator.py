#!/usr/bin/env python3
"""
Generate keymap.yaml from QMK c2json output and keymap-config.yaml

This script reads the QMK keymap JSON generated by `qmk c2json` command
and combines it with the keymap-config.yaml to produce a complete keymap.yaml
file with translated key labels and detected layer toggles.
"""

import json
import re
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple

try:
    import yaml
except ImportError:
    print("Error: PyYAML is required. Install with: pip install PyYAML", file=sys.stderr)
    sys.exit(1)


def load_qmk_config(qmk_json_path: Path) -> Tuple[str, str]:
    """
    Load qmk.json and extract keyboard/keymap parameters.

    Returns:
        Tuple of (keyboard, keymap) from the "right" build target
    """
    with open(qmk_json_path, 'r') as f:
        qmk_config = json.load(f)

    build_targets = qmk_config.get('build_targets', [])
    if len(build_targets) < 1:
        print("Error: Expected at least 1 build targets in qmk.json", file=sys.stderr)
        sys.exit(1)

    # Use the "right" build target (index 1)
    keyboard, keymap = build_targets[0]
    return keyboard, keymap


def build_standard_mapping() -> Dict[str, str]:
    """
    Build standard QMK keycode → label mappings.

    Returns:
        Dictionary mapping QMK keycodes to display labels
    """
    mapping = {}

    # Letters
    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
        mapping[f'KC_{letter}'] = letter

    # Numbers
    for num in range(10):
        mapping[f'KC_{num}'] = str(num)

    # Number row symbols
    mapping.update({
        'KC_EXLM': '!',
        'KC_AT': '@',
        'KC_HASH': '#',
        'KC_DLR': '$',
        'KC_PERC': '%',
        'KC_CIRC': '^',
        'KC_AMPR': '&',
        'KC_ASTR': '*',
        'KC_LPRN': '(',
        'KC_RPRN': ')',
    })

    # Punctuation and symbols
    mapping.update({
        'KC_MINS': '-',
        'KC_EQL': '=',
        'KC_LBRC': '[',
        'KC_RBRC': ']',
        'KC_BSLS': '\\',
        'KC_SCLN': ';',
        'KC_QUOT': "'",
        'KC_GRV': '`',
        'KC_COMMA': ',',
        'KC_DOT': '.',
        'KC_SLASH': '/',
        'KC_UNDS': '_',
        'KC_PLUS': '+',
        'KC_LCBR': '{',
        'KC_RCBR': '}',
        'KC_PIPE': '|',
        'KC_COLN': ':',
        'KC_DQUO': '"',
        'KC_TILD': '~',
        'KC_LT': '<',
        'KC_GT': '>',
        'KC_QUES': '?',
        'KC_SLSH': '/',
        'KC_EQUAL': '=',
        'KC_COMM': ',',
    })

    # Modifiers with NerdFont icons
    mapping.update({
        'KC_LEFT_SHIFT': '%%nf-md-apple_keyboard_shift',
        'KC_RIGHT_SHIFT': '%%nf-md-apple_keyboard_shift',
        'KC_LSFT': '%%nf-md-apple_keyboard_shift',
        'KC_RSFT': '%%nf-md-apple_keyboard_shift',
        'KC_LEFT_CTRL': '%%nf-md-apple_keyboard_control',
        'KC_RIGHT_CTRL': '%%nf-md-apple_keyboard_control',
        'KC_LCTL': '%%nf-md-apple_keyboard_control',
        'KC_RCTL': '%%nf-md-apple_keyboard_control',
        'KC_LEFT_ALT': '%%nf-md-apple_keyboard_option',
        'KC_RIGHT_ALT': '%%nf-md-apple_keyboard_option',
        'KC_LALT': '%%nf-md-apple_keyboard_option',
        'KC_RALT': '%%nf-md-apple_keyboard_option',
        'KC_LEFT_GUI': '%%nf-md-apple_keyboard_command',
        'KC_RIGHT_GUI': '%%nf-md-apple_keyboard_command',
        'KC_LGUI': '%%nf-md-apple_keyboard_command',
        'KC_RGUI': '%%nf-md-apple_keyboard_command',
    })

    # Navigation keys with arrows (both long and short forms)
    mapping.update({
        'KC_LEFT': '%%nf-fa-arrow_left',
        'KC_RIGHT': '%%nf-fa-arrow_right',
        'KC_UP': '%%nf-fa-arrow_up',
        'KC_DOWN': '%%nf-fa-arrow_down',
        'KC_RGHT': '%%nf-fa-arrow_right',  # Short form
        'KC_HOME': '↖',
        'KC_END': '↘',
        'KC_PGUP': '⇞',
        'KC_PGDN': '⇟',
    })

    # Editing keys
    mapping.update({
        'KC_ENTER': '%%nf-md-keyboard_return',
        'KC_ESC': 'ESC ⎋',
        'KC_BSPC': '%%nf-md-backspace',
        'KC_TAB': '%%nf-md-keyboard_tab',
        'KC_SPC': '%%nf-md-keyboard_space',
        'KC_DEL': '%%nf-md-backspace_reverte',
        'KC_INS': 'Ins',
    })

    # Function keys
    for fkey in range(1, 21):
        mapping[f'KC_F{fkey}'] = f'F{fkey}'

    # Keypad keys
    for num in range(10):
        mapping[f'KC_KP_{num}'] = str(num)

    mapping.update({
        'KC_PPLS': '+',
        'KC_PMNS': '-',
        'KC_PAST': '*',
        'KC_PSLS': '/',
        'KC_PEQL': '=',
        'KC_PENT': '%%nf-md-keyboard_return',
        'KC_PDOT': '.',
        'KC_PCMM': ',',
    })

    # Media keys with icons
    mapping.update({
        'KC_MUTE': '%%nf-md-volume_mute',
        'KC_VOLU': '%%nf-md-volume_plus',
        'KC_VOLD': '%%nf-md-volume_minus',
        'KC_MPLY': '%%nf-md-play_pause',
        'KC_MNXT': '%%nf-md-skip_next',
        'KC_MPRV': '%%nf-md-skip_previous',
        'KC_MFFD': '%%nf-md-fast_forward',
        'KC_MRWD': '%%nf-md-rewind',
        'KC_MSTP': '%%nf-md-stop',
    })

    # System keys
    mapping.update({
        'KC_BRIU': '%%nf-md-brightness_7',
        'KC_BRID': '%%nf-md-brightness_5',
        'KC_PWR': '%%nf-iec-power',
        'KC_SLEP': '%%nf-md-power_sleep',
        'KC_WAKE': '%%nf-md-alarm',
    })

    # Mouse buttons
    for btn in range(1, 9):
        mapping[f'KC_BTN{btn}'] = f'M{btn}'
    mapping['KC_MS_BTN1'] = 'L%%nf-md-cursor_default_click'
    mapping['KC_MS_BTN2'] = 'R%%nf-md-cursor_default_click'
    mapping['KC_MS_BTN3'] = 'M%%nf-md-cursor_default_click'
    mapping['KC_MS_BTN4'] = '4%%nf-md-cursor_default_click'
    mapping['KC_MS_BTN5'] = '5%%nf-md-cursor_default_click'
    mapping['KC_MS_BTN6'] = '6%%nf-md-cursor_default_click'
    mapping['KC_MS_BTN7'] = '7%%nf-md-cursor_default_click'
    mapping['KC_MS_BTN8'] = '8%%nf-md-cursor_default_click'

    # Special keys
    mapping.update({
        'KC_NO': '',
        'KC_TRNS': '',
        'KC_TRANSPARENT': '',
        '_______': '',
        'XXXXXXX': '',
    })

    # QMK Quantum keycodes
    mapping.update({
        'QK_CAPS_WORD_TOGGLE': '%%nf-md-apple_keyboard_caps',
        'QK_REP': '%%nf-fa-repeat REP',
        'CW_TOGG': '%%nf-md-apple_keyboard_caps',
    })

    return mapping


def build_keycode_mapping(keymap_config: Dict[str, Any]) -> Dict[str, str]:
    """
    Build complete keycode mapping by combining standard mappings with custom keyLabels.

    Args:
        keymap_config: The parsed keymap-config.yaml content

    Returns:
        Combined mapping dictionary
    """
    mapping = build_standard_mapping()

    # Add custom key labels from config
    if 'keyLabels' in keymap_config:
        mapping.update(keymap_config['keyLabels'])

    return mapping


def translate_keycode(keycode: str, mapping: Dict[str, str]) -> str:
    """
    Translate a single keycode to display label.

    Handles:
    - Direct mapping lookups
    - Modifier combinations like S(KC_TAB)
    - Layer toggle keys like MO(_MED)
    - Nested modifiers like C(G(KC_DOWN))

    Args:
        keycode: The QMK keycode to translate
        mapping: The keycode mapping dictionary

    Returns:
        Translated display label
    """
    # Check custom mapping first
    if keycode in mapping:
        return mapping[keycode]

    # Handle MO(layer) keys
    mo_match = re.match(r'MO\(([^)]+)\)', keycode)
    if mo_match:
        layer_name = mo_match.group(1)
        # Remove leading underscore if present
        layer_name = layer_name.lstrip('_')
        return layer_name

    # Handle modifier combinations
    # Pattern: MOD(content) where MOD is S, C, A, or G
    mod_match = re.match(r'([SCAG])\((.+)\)', keycode)
    if mod_match:
        modifier = mod_match.group(1)
        inner_content = mod_match.group(2)

        # Map modifier to icon
        mod_icons = {
            'S': '%%nf-md-apple_keyboard_shift',
            'C': '%%nf-md-apple_keyboard_command',
            'A': '%%nf-md-apple_keyboard_option',
            'G': '%%nf-md-apple_keyboard_command',
        }

        # Recursively translate inner content
        inner_label = translate_keycode(inner_content, mapping)

        # Combine modifier icon with inner label
        if inner_label:
            return f"{mod_icons[modifier]} {inner_label}"
        else:
            return mod_icons[modifier]

    # Fallback: return keycode as-is
    return keycode


def generate_labels(layer_keycodes: List[str], mapping: Dict[str, str]) -> List[List[str]]:
    """
    Generate labels array for a layer by splitting 60-key array into 10 clusters.

    Key matrix layout (60 keys):
    - indices 0-5: FR1 (Right finger 1)
    - indices 6-11: FR2
    - indices 12-17: FR3
    - indices 18-23: FR4
    - indices 24-29: FL1 (Left finger 1)
    - indices 30-35: FL2
    - indices 36-41: FL3
    - indices 42-47: FL4
    - indices 48-53: TCR (Thumb cluster right)
    - indices 54-59: TCL (Thumb cluster left)

    Args:
        layer_keycodes: List of 60 keycodes for this layer
        mapping: Keycode mapping dictionary

    Returns:
        List of 10 sub-arrays, each containing 6 translated labels
    """
    if len(layer_keycodes) != 60:
        print(f"Warning: Expected 60 keys, got {len(layer_keycodes)}", file=sys.stderr)

    labels = []

    # Split into 10 clusters of 6 keys each
    for cluster_idx in range(10):
        start_idx = cluster_idx * 6
        end_idx = start_idx + 6
        cluster_keycodes = layer_keycodes[start_idx:end_idx]

        # Translate each keycode in the cluster
        cluster_labels = [translate_keycode(kc, mapping) for kc in cluster_keycodes]
        labels.append(cluster_labels)

    return labels


def detect_layer_toggles(
    layer_keycodes: List[str],
    key_layer_toggles: Dict[str, int],
    layer_ids: Dict[str, int]
) -> List[List[Optional[int]]]:
    """
    Detect layer toggle keys and generate layerToggles structure.

    Checks keyLayerToggles mapping first, then falls back to MO() key detection.
    Layer toggles are typically on thumb cluster keys, but we check all positions.
    The structure is [right_side_toggles, left_side_toggles], where each side
    has 6 values corresponding to finger cluster key positions.

    Args:
        layer_keycodes: List of 60 keycodes for this layer
        key_layer_toggles: Mapping from keycode to layer index (from keymap-config.yaml)
        layer_ids: Mapping from layer name to layer index (from keymap-config.yaml)

    Returns:
        Two arrays: [[right_toggles], [left_toggles]]
        Each array has 6 values (one per finger position), either layer index or None
    """
    # Initialize with None values
    right_toggles = [None] * 6
    left_toggles = [None] * 6

    # Check thumb clusters for layer toggle keys
    # TCR (indices 48-53): [Down, Pad, Up, Nail, Knuckle, Double-Down]
    # TCL (indices 54-59): [Down, Pad, Up, Nail, Knuckle, Double-Down]

    # For thumb cluster Pad/Nail/Knuckle keys (positions 1, 3, 4)
    # Map them to finger cluster positions (used in layerToggles)
    thumb_to_finger_map = {
        1: 1,  # Pad -> North
        3: 3,  # Nail -> South
        4: 4,  # Knuckle -> West
    }

    # Check right thumb cluster (TCR, indices 48-53)
    for local_idx in range(6):
        global_idx = 48 + local_idx
        keycode = layer_keycodes[global_idx]

        layer_num = None

        # First check keyLayerToggles mapping
        if keycode in key_layer_toggles:
            layer_num = key_layer_toggles[keycode]
        else:
            # Fall back to MO() key detection
            mo_match = re.match(r'MO\(([^)]+)\)', keycode)
            if mo_match:
                layer_ref = mo_match.group(1)
                # Extract layer number (handle both numeric and _NAME formats)
                if layer_ref.startswith('_'):
                    # Use layer_ids mapping from config
                    layer_num = layer_ids.get(layer_ref, None)
                else:
                    layer_num = int(layer_ref)

        # Map thumb position to finger position for layerToggles
        if local_idx in thumb_to_finger_map and layer_num is not None:
            finger_pos = thumb_to_finger_map[local_idx]
            right_toggles[finger_pos] = layer_num

    # Check left thumb cluster (TCL, indices 54-59)
    for local_idx in range(6):
        global_idx = 54 + local_idx
        keycode = layer_keycodes[global_idx]

        layer_num = None

        # First check keyLayerToggles mapping
        if keycode in key_layer_toggles:
            layer_num = key_layer_toggles[keycode]
        else:
            # Fall back to MO() key detection
            mo_match = re.match(r'MO\(([^)]+)\)', keycode)
            if mo_match:
                layer_ref = mo_match.group(1)
                if layer_ref.startswith('_'):
                    # Use layer_ids mapping from config
                    layer_num = layer_ids.get(layer_ref, None)
                else:
                    layer_num = int(layer_ref)

        if local_idx in thumb_to_finger_map and layer_num is not None:
            finger_pos = thumb_to_finger_map[local_idx]
            left_toggles[finger_pos] = layer_num

    return [right_toggles, left_toggles]


def generate_keymap_yaml(qmk_json: Dict[str, Any], keymap_config: Dict[str, Any], output_path: Path):
    """
    Main generation logic: combine QMK JSON with keymap-config to produce keymap.yaml.

    Args:
        qmk_json: Parsed QMK JSON from c2json
        keymap_config: Parsed keymap-config.yaml
        output_path: Path to write the generated keymap.yaml
    """
    # Build keycode mapping
    mapping = build_keycode_mapping(keymap_config)

    # Extract layer configuration
    layer_ids = keymap_config.get('layerIds', {})
    key_layer_toggles = keymap_config.get('keyLayerToggles', {})

    # Generate complete keymap structure
    keymap = {'layers': []}

    layers_data = qmk_json.get('layers', [])
    config_layers = keymap_config.get('layers', [])

    if len(layers_data) != len(config_layers):
        print(f"Warning: Layer count mismatch. QMK JSON: {len(layers_data)}, Config: {len(config_layers)}", file=sys.stderr)

    # Process each layer
    for layer_idx, layer_keycodes in enumerate(layers_data):
        if layer_idx >= len(config_layers):
            print(f"Warning: No config for layer {layer_idx}, skipping", file=sys.stderr)
            continue

        config_layer = config_layers[layer_idx]

        # Generate labels
        labels = generate_labels(layer_keycodes, mapping)

        # Detect layer toggles
        layer_toggles = detect_layer_toggles(layer_keycodes, key_layer_toggles, layer_ids)

        # Combine all layer data
        layer_data = {
            'name': config_layer.get('name', f'Layer{layer_idx}'),
            'labels': labels,
            'colors': config_layer.get('colors', []),
            'primaryColor': config_layer.get('primaryColor', 0),
            'secondaryColor': config_layer.get('secondaryColor', 0),
            'layerToggles': layer_toggles,
        }

        keymap['layers'].append(layer_data)

    # Write YAML file
    with open(output_path, 'w') as f:
        yaml.dump(keymap, f, default_flow_style=False, allow_unicode=True, sort_keys=False)

    print(f"Generated keymap.yaml at {output_path}")


def generate_images_with_typst(project_root: Path):
    """
    Run typst commands to generate layer map images and overview image.

    Args:
        project_root: Root directory of the project
    """
    layers_source = project_root / 'support' / 'keymap-images' / 'keymap-layers.typ'
    overview_source = project_root / 'support' / 'keymap-images' / 'keymap-overview.typ'
    font_path = project_root / 'support' / 'keymap-images' / 'fonts'
    docs_dir = project_root / 'docs'

    # Generate individual layer map images
    print("Generating layer map images with typst...")
    layer_maps_output = docs_dir / 'keymap-{p}.png'
    cmd_layers = [
        'typst', 'compile',
        str(layers_source),
        str(layer_maps_output),
        '--ppi=120',
        f'--font-path={font_path}',
        '--ignore-system-fonts'
    ]

    try:
        subprocess.run(cmd_layers, check=True, capture_output=True, text=True)
        print(f"Generated layer maps at {docs_dir}/keymap-*.png")
    except subprocess.CalledProcessError as e:
        print(f"Error generating layer maps: {e}", file=sys.stderr)
        print(f"stderr: {e.stderr}", file=sys.stderr)
        sys.exit(1)

    # Generate overview image
    print("Generating layers overview image with typst...")
    overview_output = docs_dir / 'keymap-overview.png'
    cmd_overview = [
        'typst', 'compile',
        str(overview_source),
        str(overview_output),
        '--ppi=120',
        f'--font-path={font_path}',
        '--ignore-system-fonts'
    ]

    try:
        subprocess.run(cmd_overview, check=True, capture_output=True, text=True)
        print(f"Generated overview at {overview_output}")
    except subprocess.CalledProcessError as e:
        print(f"Error generating overview: {e}", file=sys.stderr)
        print(f"stderr: {e.stderr}", file=sys.stderr)
        sys.exit(1)


def main():
    """
    Entry point: Load qmk.json, run qmk c2json, and generate keymap.yaml.
    """
    # Determine script and project paths
    script_dir = Path(__file__).parent
    project_root = script_dir.parent.parent

    # Paths
    qmk_json_path = project_root / 'qmk.json'
    keymap_config_path = script_dir / 'keymap-config.yaml'
    output_path = script_dir / 'keymap.yaml'

    # Load qmk.json to get keyboard and keymap
    print("Loading qmk.json...")
    keyboard, keymap_name = load_qmk_config(qmk_json_path)
    print(f"Using keyboard: {keyboard}, keymap: {keymap_name}")

    # Construct keymap.c path
    # The keyboard may have variants (e.g., svalboard/trackball/pmw3389/right)
    # but the keymap.c is typically under the base keyboard directory
    # Try the full path first, then fall back to base keyboard name
    keymap_c_path = project_root / 'keyboards' / keyboard / 'keymaps' / keymap_name / 'keymap.c'

    if not keymap_c_path.exists():
        # Try with base keyboard name (first part before /)
        base_keyboard = keyboard.split('/')[0]
        keymap_c_path = project_root / 'keyboards' / base_keyboard / 'keymaps' / keymap_name / 'keymap.c'

    if not keymap_c_path.exists():
        print(f"Error: keymap.c not found at {keymap_c_path}", file=sys.stderr)
        print(f"Tried: keyboards/{keyboard}/keymaps/{keymap_name}/keymap.c", file=sys.stderr)
        print(f"   and: keyboards/{base_keyboard}/keymaps/{keymap_name}/keymap.c", file=sys.stderr)
        sys.exit(1)

    # Run qmk c2json command
    print("Running qmk c2json...")
    cmd = [
        'qmk', 'c2json',
        '-kb', keyboard,
        '-km', keymap_name,
        str(keymap_c_path),
        '--no-cpp'
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        qmk_json = json.loads(result.stdout)
    except subprocess.CalledProcessError as e:
        print(f"Error running qmk c2json: {e}", file=sys.stderr)
        print(f"stderr: {e.stderr}", file=sys.stderr)
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"Error parsing QMK JSON output: {e}", file=sys.stderr)
        sys.exit(1)

    # Load keymap-config.yaml
    print("Loading keymap-config.yaml...")
    with open(keymap_config_path, 'r') as f:
        keymap_config = yaml.safe_load(f)

    # Generate keymap.yaml
    print("Generating keymap.yaml...")
    generate_keymap_yaml(qmk_json, keymap_config, output_path)

    # Generate images with typst
    generate_images_with_typst(project_root)

    # Clean up intermediate file
    print("Cleaning up intermediate files...")
    if output_path.exists():
        output_path.unlink()
        print(f"Deleted {output_path}")

    print("Done!")


if __name__ == '__main__':
    main()
