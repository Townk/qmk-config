#!/usr/bin/env python3
"""
Generate keymap.yaml from QMK c2json output and keymap-config.yaml

This script reads the QMK keymap JSON generated by `qmk c2json` command
and combines it with the keymap-config.yaml to produce a complete keymap.yaml
file with translated key labels and detected layer toggles.
"""

import argparse
import colorsys
import json
import re
import subprocess
import sys
from pathlib import Path
from typing import Callable, Dict, List, Any, Optional, Tuple, Union

try:
    import yaml
except ImportError:
    print(
        "Error: PyYAML is required. Install with: pip install PyYAML", file=sys.stderr
    )
    sys.exit(1)


try:
    import typst
except ImportError:
    print("Error: typst is required. Install with: pip install typst", file=sys.stderr)
    sys.exit(1)


def str_to_rgb(hex_str: str) -> Tuple[float, float, float]:
    """
    Convert a hex color string to RGB values in 0-1 range.

    Args:
        hex_str: Hex color string (with or without '#' prefix)

    Returns:
        Tuple of (red, green, blue) values in 0-1 range
    """
    hex_str = hex_str.lstrip("#")
    r, g, b = (int(hex_str[i : i + 2], 16) / 255.0 for i in (0, 2, 4))
    return (r, g, b)


def hex_str(red: float, green: float, blue: float) -> str:
    """
    Convert RGB values to a hex color string.

    Args:
        red: Red value in 0-1 range
        green: Green value in 0-1 range
        blue: Blue value in 0-1 range

    Returns:
        Hex color string (e.g., "#FF00AA")
    """
    return f"#{int(red * 255):02X}{int(green * 255):02X}{int(blue * 255):02X}"


class QmkContext:
    """
    Runtime context for the keymap generator script.

    Handles all path discovery, configuration loading, and provides logging.
    """

    project_root: Path

    _verbose: bool
    _qmk_json_path: Path
    _color_h_path: Path
    _keymap_c_path: Path
    _keyboard: str
    _keymap_name: str

    # Private fields for lazy-loaded properties
    _keymap_json: Optional[Dict[str, Any]]
    _keymap_config: Optional[Dict[str, Any]]
    _qmk_colors: Optional[Dict[str, str]]

    def __init__(self, verbose: bool = False, color_header_path: Optional[Path] = None):
        """
        Initialize the context and discover all paths and configuration.

        Args:
            verbose: Whether to enable verbose output
            color_header_path: Optional explicit path to QMK color.h file
        """
        self._verbose = verbose

        # Query QMK CLI for overlay directory (userspace)
        self.info("Querying QMK CLI for overlay directory...")
        overlay_dir = self._get_qmk_overlay_dir()

        if overlay_dir:
            self.project_root = overlay_dir
            self.info(f"Using overlay directory as project root: {self.project_root}")
        else:
            # Fallback to script-relative path
            self.project_root = Path(__file__).parent.parent.parent
            self.info(
                f"Falling back to script-relative project root: {self.project_root}"
            )

        # Set derived paths
        self._qmk_json_path = self.project_root / "qmk.json"

        # Determine color.h path
        if color_header_path:
            self._color_h_path = color_header_path
            self.info(f"Using provided color.h path: {self._color_h_path}")
        else:
            # Query QMK CLI for QMK home
            self.info("Querying QMK CLI for QMK home...")
            qmk_home = self._get_qmk_home()
            if qmk_home:
                self._color_h_path = qmk_home / "quantum" / "color.h"
                self.info(f"Found QMK home at {qmk_home}")
                self.info(f"Using color.h path: {self._color_h_path}")
            else:
                # Fallback: use a non-existent path (will trigger black color fallback)
                self._color_h_path = Path("/dev/null/color.h")
                self.warn(
                    "Warning: Could not determine QMK home. Named colors will fallback to black."
                )

        # Load qmk.json to get keyboard and keymap
        self.info("Loading qmk.json...")
        self._keyboard, self._keymap_name = self._read_keyboard_keymap()
        self.info(f"Using keyboard: {self._keyboard}, keymap: {self._keymap_name}")

        # Resolve keymap.c path
        self._keymap_c_path = self._resolve_keymap_path()

        # Initialize lazy-loaded properties
        self._keymap_json = None
        self._keymap_config = None
        self._qmk_colors = None

    @property
    def keymap_json(self) -> Dict[str, Any]:
        """
        Lazy-loaded keymap JSON from c2json.

        Returns:
            Parsed JSON dictionary from QMK c2json command
        """
        if self._keymap_json is None:
            self._keymap_json = self._keymap_to_json()
        return self._keymap_json

    @property
    def qmk_colors(self) -> Dict[str, str]:
        """
        Lazy-loaded QMK color definitions from color.h.

        Returns:
            Dictionary mapping color names (lowercase) to hex color strings
        """
        if self._qmk_colors is None:
            self._qmk_colors = self._read_qmk_colors()
        return self._qmk_colors

    def info(self, *args: Union[str, Callable[[], str]]):
        """
        Print an informational message if verbose mode is enabled.

        Args:
            args: one or more lines of messages to print. This line of message
                  can be a string or a function that returns a string, in
                  which case this function calls it before printing.
        """
        self._log(sys.stdout, *args)

    def warn(self, *args: Union[str, Callable[[], str]]):
        """
        Print a warning message to the stderr output, regardless of the
        verbose mode.

        Args:
            args: one or more lines of messages to print. This line of message
                  can be a string or a function that returns a string, in
                  which case this function calls it before printing.
        """
        self._log(sys.stderr, *args)

    def error(self, *args: Union[str, Callable[[], str]]):
        """
        Print an error message to the stderr output, regardless of the
        verbose mode, and exit the script with the error code `1`.

        Args:
            args: one or more lines of messages to print. This line of message
                  can be a string or a function that returns a string, in
                  which case this function calls it before printing.
        """
        self._log(sys.stderr, *args)
        sys.exit(1)

    def _log(self, output, *args):
        if self._verbose:
            for message in args:
                if callable(message):
                    print(message(), file=output)
                else:
                    print(message, file=output)

    def _run_qmk_cli(self, args: List[str]) -> Optional[str]:
        """
        Run a QMK CLI command and return its output.

        Args:
            args: Command arguments (without 'qmk' prefix)

        Returns:
            Command output as string, or None if command failed
        """
        cmd = ["qmk"] + args

        self.info(f"Running: {' '.join(cmd)}")

        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return result.stdout.strip()
        except subprocess.CalledProcessError as e:
            self.warn(f"Error running qmk command: {e}")
            if e.stderr:
                self.warn(f"stderr: {e.stderr}")
            return None
        except FileNotFoundError:
            self.warn("Error: qmk command not found. Please install QMK CLI.")
            return None

    def _keymap_to_json(self) -> Dict[str, Any]:
        """
        Run qmk c2json command to convert keymap.c to JSON.

        Returns:
            Parsed JSON dictionary from QMK

        Raises:
            SystemExit: If command fails or JSON parsing fails
        """
        output = self._run_qmk_cli(
            [
                "c2json",
                "-kb",
                self._keyboard,
                "-km",
                self._keymap_name,
                str(self._keymap_c_path),
                "--no-cpp",
            ]
        )

        if output is None:
            self.error("Error: Failed to run qmk c2json")

        try:
            return json.loads(output)
        except json.JSONDecodeError as e:
            self.error(f"Error parsing QMK JSON output: {e}")

    def _get_qmk_home(self) -> Optional[Path]:
        """
        Query QMK CLI for the QMK home directory.

        Returns:
            Path to QMK home, or None if not found
        """
        output = self._run_qmk_cli(["config", "-ro", "user.qmk_home"])
        if output and "=" in output:
            _, qmk_home = output.split("=", 1)
            return Path(qmk_home.strip())
        return None

    def _get_qmk_overlay_dir(self) -> Optional[Path]:
        """
        Query QMK CLI for the user overlay directory (userspace).

        Returns:
            Path to overlay directory, or None if not found
        """
        output = self._run_qmk_cli(["config", "-ro", "user.overlay_dir"])
        if output and "=" in output:
            _, overlay_dir = output.split("=", 1)
            return Path(overlay_dir.strip())
        return None

    def _read_keyboard_keymap(self) -> Tuple[str, str]:
        """
        Load qmk.json and extract keyboard/keymap parameters.

        Returns:
            Tuple of (keyboard, keymap) from the "right" build target
        """
        with open(self._qmk_json_path, "r") as f:
            qmk_config = json.load(f)

        build_targets = qmk_config.get("build_targets", [])
        if len(build_targets) < 1:
            self.error("Error: Expected at least 1 build targets in qmk.json")

        # Use the "right" build target (index 1)
        keyboard, keymap = build_targets[0]
        return keyboard, keymap

    def _resolve_keymap_path(self) -> Path:
        """
        Resolve the path to keymap.c, trying multiple locations.

        Returns:
            Path to keymap.c if found

        Raises:
            SystemExit: If keymap.c cannot be found
        """
        # Try full keyboard path first
        keymap_c_path = (
            self.project_root
            / "keyboards"
            / self._keyboard
            / "keymaps"
            / self._keymap_name
            / "keymap.c"
        )

        if keymap_c_path.exists():
            return keymap_c_path

        # Try with base keyboard name (first part before /)
        base_keyboard = self._keyboard.split("/")[0]
        keymap_c_path = (
            self.project_root
            / "keyboards"
            / base_keyboard
            / "keymaps"
            / self._keymap_name
            / "keymap.c"
        )

        if keymap_c_path.exists():
            return keymap_c_path

        # Not found - print error and exit
        self.error(
            f"Error: keymap.c not found at {keymap_c_path}",
            f"Tried: keyboards/{self._keyboard}/keymaps/{self._keymap_name}/keymap.c",
            f"  and: keyboards/{base_keyboard}/keymaps/{self._keymap_name}/keymap.c",
        )

    def _darken_color(
        self,
        hex_color: str,
        target_lightness: float = 0.31,
        target_saturation: float = 0.50,
    ) -> str:
        """
        Darken and desaturate a color to make it suitable for backgrounds with white text.

        QMK colors are very bright and saturated. This function makes them more subdued
        and professional-looking while preserving the color characteristic.

        Args:
            hex_color: Hex color string
            target_lightness: Target lightness value (0-1), default 0.31 (31%)
            target_saturation: Target saturation value (0-1), default 0.50 (50%)

        Returns:
            Darkened and desaturated hex color string
        """
        # Convert hex to RGB
        red, green, blue = str_to_rgb(hex_color)

        # Convert to HLS (note: colorsys uses HLS not HSL)
        hue, _, saturation = colorsys.rgb_to_hls(red, green, blue)

        # Reduce both saturation and lightness to target values
        # This makes bright colors like yellow and cyan more muted and readable
        s_adjusted = min(saturation, target_saturation)
        l_adjusted = target_lightness

        # Convert back to RGB then hex
        r_new, g_new, b_new = colorsys.hls_to_rgb(hue, l_adjusted, s_adjusted)
        return hex_str(r_new, g_new, b_new)

    def _read_qmk_colors(self) -> Dict[str, str]:
        """
        Parse QMK's color.h file to extract RGB color definitions.

        Colors are automatically darkened for better white text readability.

        Returns:
            Dictionary mapping color names (lowercase) to darkened hex color strings
        """
        colors = {}

        if not self._color_h_path.exists():
            self.warn(f"Warning: color.h not found at {self._color_h_path}")
            return colors

        with open(self._color_h_path, "r") as f:
            for line in f:
                # Match lines like: #define RGB_AZURE       0x99, 0xF5, 0xFF
                match = re.match(
                    r"#define\s+RGB_(\w+)\s+0x([0-9A-Fa-f]{2}),\s*0x([0-9A-Fa-f]{2}),\s*0x([0-9A-Fa-f]{2})",
                    line,
                )
                if match:
                    name = match.group(1).lower()
                    r = match.group(2)
                    g = match.group(3)
                    b = match.group(4)

                    # Construct hex color directly from RGB values
                    hex_color = f"#{r.upper()}{g.upper()}{b.upper()}"

                    # Darken QMK colors for better white text readability
                    darkened_color = self._darken_color(hex_color)
                    colors[name] = darkened_color

        return colors


class KeymapGenerator:
    _ctx: QmkContext
    _script_dir: Path
    _keymap_config_path: Path
    _output_path: Path
    _label_map: Dict[str, str]
    _keymap_data: Dict[str, Any]

    def __init__(self, ctx: QmkContext) -> None:
        self._ctx = ctx

        self._script_dir = Path(__file__).parent
        self._keymap_config_path = self._script_dir / "keymap-config.yaml"
        self._output_path = self._script_dir / "keymap.yaml"

        self._label_map = {}
        self._keymap_data = {}
        self._keymap_config = None

    @property
    def keymap_config(self) -> Dict[str, Any]:
        """
        Lazy-loaded keymap configuration from keymap-config.yaml.

        Returns:
            Parsed YAML dictionary from keymap-config.yaml
        """
        if self._keymap_config is None:
            self._ctx.info("Loading keymap-config.yaml...")
            with open(self._keymap_config_path, "r") as f:
                loaded_config = yaml.safe_load(f)
                if loaded_config is None:
                    self._ctx.error(
                        f"Error: {self._keymap_config_path} is empty or invalid"
                    )
                self._keymap_config = loaded_config
        return self._keymap_config

    @property
    def keymap_labels(self) -> Dict[str, str]:
        """
        Lazily build complete keycode mapping by combining standard mappings
        with custom keyLabels.

        Returns:
            Combined mapping dictionary
        """
        if len(self._label_map) == 0:
            self._label_map = self._build_standard_mapping()

            # Add custom key labels from config
            if "keyLabels" in self.keymap_config:
                self._label_map.update(self.keymap_config["keyLabels"])
        return self._label_map

    @property
    def keymap_data(self) -> Dict[str, Any]:
        """
        Main generation logic: combine QMK JSON with keymap-config to produce keymap.yaml.

        Args:
            ctx: Runtime context containing paths and configuration
        """
        if len(self._keymap_data) == 0:
            # Extract layer configuration
            layer_ids = self.keymap_config.get("layerIds", {})
            key_layer_toggles = self.keymap_config.get("keyLayerToggles", {})
            global_secondary_color = self.keymap_config.get("secondaryColor", "#70768B")

            # Generate complete keymap structure
            self._keymap_data = {"layers": []}

            layers_data = self._ctx.keymap_json.get("layers", [])
            config_layers = self.keymap_config.get("layers", [])

            if len(layers_data) != len(config_layers):
                self._ctx.warn(
                    f"Warning: Layer count mismatch. QMK JSON: {len(layers_data)}, Config: {len(config_layers)}"
                )

            # Process each layer
            for layer_idx, layer_keycodes in enumerate(layers_data):
                if layer_idx >= len(config_layers):
                    self._ctx.warn(
                        f"Warning: No config for layer {layer_idx}, skipping"
                    )
                    continue

                config_layer = config_layers[layer_idx]

                # Generate labels
                labels = self._generate_labels(layer_keycodes)

                # Detect layer toggles
                layer_toggles = self._detect_layer_toggles(
                    layer_keycodes, key_layer_toggles, layer_ids
                )

                # Generate or use existing colors
                if "baseColor" in config_layer:
                    # Resolve base color (supports color names and hex)
                    base_color_input = config_layer["baseColor"]
                    base_color = self._resolve_color(base_color_input)
                    base_index = config_layer.get("baseColorIndex", 2)
                    colors = self._generate_color_gradient(base_color, base_index)

                    # Always append global secondary color
                    colors.append(global_secondary_color)

                    # Primary color is the base color (index 2 by default)
                    # Secondary color is the appended color (index 6 after appending)
                    primary_color = base_index
                    secondary_color = len(colors) - 1
                else:
                    # Use existing colors array (backward compatibility)
                    colors = config_layer.get("colors", [])
                    primary_color = config_layer.get("primaryColor", 0)
                    secondary_color = config_layer.get("secondaryColor", 0)

                # Combine all layer data
                layer_data = {
                    "name": config_layer.get("name", f"Layer{layer_idx}"),
                    "labels": labels,
                    "colors": colors,
                    "primaryColor": primary_color,
                    "secondaryColor": secondary_color,
                    "layerToggles": layer_toggles,
                }

                self._keymap_data["layers"].append(layer_data)
        return self._keymap_data

    def make_keymap_images(self, output_path: Path):
        """
        Run typst commands to generate layer map images and overview image.

        Args:
            ctx: Runtime context containing paths and configuration
        """
        layers_source = self._script_dir / "keymap-layers.typ"
        overview_source = self._script_dir / "keymap-overview.typ"
        font_path = self._script_dir / "fonts"

        data_file = self._script_dir / "keymap.yaml"
        # Generate the keymap data file to be used by typst
        with open(data_file, "w") as f:
            # Write YAML file
            yaml.dump(
                self.keymap_data,
                f,
                default_flow_style=False,
                allow_unicode=True,
                sort_keys=False,
            )
        self._ctx.info(f"Generated keymap.yaml at {data_file}")

        # Generate individual layer map images
        self._ctx.info("Generating layer map images with typst...")
        layer_maps_output = output_path / "keymap-{p}.svg"
        typst.compile(
            input=layers_source,
            output=layer_maps_output,
            ppi=120,
            font_paths=[font_path],
            ignore_system_fonts=True,
        )
        self._ctx.info(f"Generated layer maps at {output_path}/keymap-*.png")

        # Generate overview image
        self._ctx.info("Generating layers overview image with typst...")
        overview_output = output_path / "keymap-overview.svg"
        typst.compile(
            input=overview_source,
            output=overview_output,
            ppi=120,
            font_paths=[font_path],
            ignore_system_fonts=True,
        )
        self._ctx.info(f"Generated overview at {overview_output}")

        self._ctx.info("Cleaning up intermediate data file...")
        if data_file.exists():
            data_file.unlink()
            self._ctx.info(f"Deleted {data_file}")

    def _build_standard_mapping(self) -> Dict[str, str]:
        """
        Build standard QMK keycode → label mappings.

        Returns:
            Dictionary mapping QMK keycodes to display labels
        """
        mapping = {}

        # Letters
        for letter in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
            mapping[f"KC_{letter}"] = letter

        # Numbers
        for num in range(10):
            mapping[f"KC_{num}"] = str(num)

        # Function keys
        for fkey in range(1, 25):
            mapping[f"KC_F{fkey}"] = f"F{fkey}"

        # Number pad keys
        for num in range(10):
            mapping[f"KC_KP_{num}"] = str(num)

        # Mouse buttons
        for btn in range(1, 9):
            if btn == 1:
                mapping["KC_BTN1"] = "L %%nf-md-cursor_default_click;"
                mapping["KC_MS_BTN1"] = "L %%nf-md-cursor_default_click;"
            elif btn == 2:
                mapping["KC_BTN2"] = "R %%nf-md-cursor_default_click;"
                mapping["KC_MS_BTN2"] = "R %%nf-md-cursor_default_click;"
            elif btn == 3:
                mapping["KC_BTN3"] = "M %%nf-md-cursor_default_click;"
                mapping["KC_MS_BTN3"] = "M %%nf-md-cursor_default_click;"
            else:
                mapping[f"KC_BTN{btn}"] = f"{btn} %%nf-md-cursor_default_click;"
                mapping[f"KC_MS_BTN{btn}"] = f"{btn} %%nf-md-cursor_default_click;"

        # All other keycodes in one consolidated dict
        mapping.update(
            {
                # Punctuation and symbols
                "KC_ENTER": "%%nf-md-keyboard_return;",
                "KC_ENT": "@@KC_ENTER;",
                "KC_ESC": "ESC ⎋",
                "KC_ESCAPE": "@@KC_ESC;",
                "KC_BACKSPACE": "%%nf-md-backspace;",
                "KC_BSPC": "@@KC_BACKSPACE;",
                "KC_TAB": "%%nf-md-keyboard_tab;",
                "KC_SPACE": "%%nf-md-keyboard_space;",
                "KC_SPC": "@@KC_SPACE;",
                "KC_MINUS": "-",
                "KC_MINS": "@@KC_MINUS;",
                "KC_EQUAL": "=",
                "KC_EQL": "@@KC_EQUAL;",
                "KC_LEFT_BRACKET": "[",
                "KC_LBRC": "@@KC_LEFT_BRACKET;",
                "KC_RIGHT_BRACKET": "]",
                "KC_RBRC": "@@KC_RIGHT_BRACKET;",
                "KC_BACKSLASH": "\\",
                "KC_BSLS": "@@KC_BACKSLASH;",
                "KC_NONUS_HASH": "#",
                "KC_NUHS": "@@KC_NONUS_HASH;",
                "KC_SEMICOLON": ";",
                "KC_SCLN": "@@KC_SEMICOLON;",
                "KC_QUOTE": "'",
                "KC_QUOT": "@@KC_QUOTE;",
                "KC_GRAVE": "`",
                "KC_GRV": "@@KC_GRAVE;",
                "KC_COMMA": ",",
                "KC_COMM": "@@KC_COMMA;",
                "KC_DOT": ".",
                "KC_SLASH": "/",
                "KC_SLSH": "@@KC_SLASH;",
                "KC_NONUS_BACKSLASH": "\\",
                "KC_NUBS": "@@KC_NONUS_BACKSLASH;",
                # Lock keys
                "KC_CAPS_LOCK": "%%nf-md-apple_keyboard_caps;",
                "KC_CAPS": "@@KC_CAPS_LOCK;",
                "KC_SCROLL_LOCK": "ScrLK",
                "KC_SCRL": "@@KC_SCROLL_LOCK;",
                "KC_NUM_LOC": "NumLK",
                "KC_NUM": "@@KC_NUM_LOC;",
                "KC_LOCKING_CAPS_LOCK": "LKCaps",
                "KC_LCAP": "@@KC_LOCKING_CAPS_LOCK;",
                "KC_LOCKING_NUM_LOCK": "LKNum",
                "KC_LNUM": "@@KC_LOCKING_NUM_LOCK;",
                "KC_LOCKING_SCROLL_LOCK": "LKScrLK",
                "KC_LSCR": "@@KC_LOCKING_SCROLL_LOCK;",
                # Modifiers with NerdFont icons
                "KC_LEFT_SHIFT": "%%nf-md-apple_keyboard_shift;",
                "KC_RIGHT_SHIFT": "@@KC_LEFT_SHIFT;",
                "KC_LSFT": "@@KC_LEFT_SHIFT;",
                "KC_RSFT": "@@KC_LEFT_SHIFT;",
                "KC_LEFT_CTRL": "%%nf-md-apple_keyboard_control;",
                "KC_RIGHT_CTRL": "@@KC_LEFT_CTRL;",
                "KC_LCTL": "@@KC_LEFT_CTRL;",
                "KC_RCTL": "@@KC_LEFT_CTRL;",
                "KC_LEFT_ALT": "%%nf-md-apple_keyboard_option;",
                "KC_RIGHT_ALT": "@@KC_LEFT_ALT;",
                "KC_LALT": "@@KC_LEFT_ALT;",
                "KC_RALT": "@@KC_LEFT_ALT;",
                "KC_LOPT": "@@KC_LEFT_ALT;",
                "KC_ROPT": "@@KC_LEFT_ALT;",
                "KC_LEFT_GUI": "%%nf-md-apple_keyboard_command;",
                "KC_RIGHT_GUI": "@@KC_LEFT_GUI;",
                "KC_LGUI": "@@KC_LEFT_GUI;",
                "KC_RGUI": "@@KC_LEFT_GUI;",
                "KC_LCMD": "@@KC_LEFT_GUI;",
                "KC_RCMD": "@@KC_LEFT_GUI;",
                "KC_LWIN": "@@KC_LEFT_GUI;",
                "KC_RWIN": "@@KC_LEFT_GUI;",
                # Command keys
                "KC_PRINT_SCREEN": "%%nf-md-monitor_screenshot;",
                "KC_PSCR": "@@KC_PRINT_SCREEN;",
                "KC_PAUSE": "%%nf-md-pause_circle_outline;",
                "KC_PAUS": "@@KC_PAUSE;",
                "KC_BRK": "@@KC_PAUSE;",
                "KC_INSERT": "Ins",
                "KC_INS": "@@KC_INSERT;",
                "KC_HOME": "↖",
                "KC_PAGE_UP": "⇞",
                "KC_PGUP": "@@KC_PAGE_UP;",
                "KC_DELETE": "%%nf-md-backspace_reverse;",
                "KC_DEL": "@@KC_DELETE;",
                "KC_END": "↘",
                "KC_PAGE_DOWN": "⇟",
                "KC_PGDN": "@@KC_PAGE_DOWN;",
                "KC_RIGHT": "%%nf-fa-arrow_right;",
                "KC_RGHT": "%%nf-fa-arrow_right;",
                "KC_LEFT": "%%nf-fa-arrow_left;",
                "KC_DOWN": "%%nf-fa-arrow_down;",
                "KC_UP": "%%nf-fa-arrow_up;",
                "KC_APPLICATION": "%%nf-md-application;",
                "KC_APP": "%%nf-md-application;",
                "KC_KB_POWER": "%%nf-md-power_plug;",
                "KC_EXECUTE": "%%nf-md-run_fast;",
                "KC_EXEC": "@@KC_EXECUTE;",
                "KC_HELP": "%%nf-md-help;",
                "KC_MENU": "%%nf-md-menu;",
                "KC_SELECT": "%%nf-md-select;",
                "KC_SLCT": "@@KC_SELECT;",
                "KC_STOP": "%nf-fa-stop",
                "KC_AGAIN": "%%nf-md-redo;",
                "KC_AGIN": "@@KC_AGAIN;",
                "KC_UNDO": "%%nf-md-undo;",
                "KC_CUT": "%%nf-md-content_cut;",
                "KC_COPY": "%%nf-md-content_copy;",
                "KC_PASTE": "%%nf-md-content_paste;",
                "KC_PSTE": "@@KC_PASTE;",
                "KC_FIND": "%%nf-md-file_find;",
                "KC_KB_MUTE": "%%nf-fa-volume_xmark;",
                "KC_KB_VOLUME_UP": "%nf-fa-volume_up",
                "KC_KB_VOLUME_DOWN": "%%nf-fa-volume_down;",
                "KC_ALTERNATE_ERASE": "%%nf-md-eraser;",
                "KC_ERAS": "@@KC_ALTERNATE_ERASE;",
                "KC_SYSTEM_REQUEST": "SysReq",
                "KC_SYRQ": "@@KC_SYSTEM_REQUEST;",
                "KC_CANCEL": "%%nf-md-cancel;",
                "KC_CNCL": "@@KC_CANCEL;",
                "KC_CLEAR": "%%nf-md-broom;",
                "KC_CLR": "@@KC_CLEAR;",
                "KC_PRIOR": "@@KC_PGUP;",
                "KC_PRIR": "@@KC_PGUP;",
                "KC_NEXT": "@@KC_PGDN;",
                "KC_RETURN": "⌅",
                "KC_RETN": "@@KC_RETURN;",
                "KC_SEPARATOR": "%%nf-md-decimal;",
                "KC_SEPR": "@@KC_SEPARATOR;",
                "KC_OUT": "%%nf-md-exit_to_app;",
                "KC_OPER": "%%nf-fa-terminal;",
                "KC_CLEAR_AGAIN": "@@KC_CLEAR;²",
                "KC_CLAG": "@@KC_CLEAR_AGAIN;",
                "KC_CRSEL": "%%nf-md-form_textbox;",
                "KC_CRSL": "@@KC_CRSEL;",
                "KC_EXSEL": "%%nf-md-form_textbox;+",
                "KC_EXSL": "@@KC_EXSEL;+",
                # Media keys with icons
                "KC_SYSTEM_POWER": "%%nf-md-power;",
                "KC_PWR": "@@KC_SYSTEM_POWER;",
                "KC_SYSTEM_SLEEP": "%%nf-md-power_sleep;",
                "KC_SLEP": "@@KC_SYSTEM_SLEEP;",
                "KC_SYSTEM_WAKE": "%%nf-md-alarm;",
                "KC_WAKE": "@@KC_SYSTEM_WAKE;",
                "KC_AUDIO_MUTE": "%%nf-md-volume_mute;",
                "KC_MUTE": "@@KC_AUDIO_MUTE;",
                "KC_AUDIO_VOL_UP": "%%nf-md-volume_plus;",
                "KC_VOLU": "@@KC_AUDIO_VOL_UP;",
                "KC_AUDIO_VOL_DOWN": "%%nf-md-volume_minus;",
                "KC_VOLD": "@@KC_AUDIO_VOL_DOWN;",
                "KC_MEDIA_NEXT_TRACK": "%%nf-md-skip_next;",
                "KC_MNXT": "@@KC_MEDIA_NEXT_TRACK;",
                "KC_MEDIA_PREV_TRACK": "%%nf-md-skip_previous;",
                "KC_MPRV": "@@KC_MEDIA_PREV_TRACK;",
                "KC_MEDIA_STOP": "%%nf-md-stop;",
                "KC_MSTP": "@@KC_MEDIA_STOP;",
                "KC_MEDIA_PLAY_PAUSE": "%%nf-md-play_pause;",
                "KC_MPLY": "@@KC_MEDIA_PLAY_PAUSE;",
                "KC_MEDIA_SELECT": "%%nf-oct-file_media;",
                "KC_MSEL": "@@KC_MEDIA_SELECT;",
                "KC_MEDIA_EJECT": "%%nf-fa-eject;",
                "KC_EJCT": "@@KC_MEDIA_EJECT;",
                "KC_MAIL": "%%nf-cod-mail;",
                "KC_CALCULATOR": "%%nf-md-calculator;",
                "KC_CALC": "@@KC_CALCULATOR;",
                "KC_MY_COMPUTER": "%%nf-md-desktop_classic;",
                "KC_MYCM": "@@KC_MY_COMPUTER;",
                "KC_WWW_SEARCH": "%%nf-md-search_web;",
                "KP_WSCH": "@@KC_WWW_SEARCH;",
                "KC_WWW_HOME": "%%nf-fa-home;",
                "KC_WHOM": "@@KC_WWW_HOME;",
                "KC_WWW_BACK": "%%nf-md-arrow_left_bold;",
                "KC_WBAK": "@@KC_WWW_BACK;",
                "KC_WWW_FORWARD": "%%nf-md-arrow_right_bold;",
                "KC_WFWD": "@@KC_WWW_FORWARD;",
                "KC_WWW_STOP": "%%nf-fa-stop;",
                "KC_WSTP": "@@KC_WWW_STOP;",
                "KC_WWW_REFRESH": "%%nf-md-web_refresh;",
                "KC_WREF": "@@KC_WWW_REFRESH;",
                "KC_WWW_FAVORITES": "%%nf-seti-favicon;",
                "KC_WFAV": "@@KC_WWW_FAVORITES;",
                "KC_MEDIA_FAST_FORWARD": "%%nf-md-fast_forward;",
                "KC_MFFD": "@@KC_MEDIA_FAST_FORWARD;",
                "KC_MEDIA_REWIND": "%%nf-md-rewind;",
                "KC_MRWD": "@@KC_MEDIA_REWIND;",
                "KC_BRIGHTNESS_UP": "%%nf-md-brightness_7;",
                "KC_BRIU": "@@KC_BRIGHTNESS_UP;",
                "KC_BRMU": "@@KC_BRIGHTNESS_UP;",
                "KC_BRIGHTNESS_DOWN": "%%nf-md-brightness_5;",
                "KC_BRID": "@@KC_BRIGHTNESS_DOWN;",
                "KC_BRMD": "@@KC_BRIGHTNESS_DOWN;",
                "KC_CONTROL_PANEL": "%%nf-cod-settings_gear;",
                "KC_CPNL": "@@KC_CONTROL_PANEL;",
                "KC_ASSISTANT": "%%nf-md-assistant;",
                "KC_ASST": "@@KC_ASSISTANT;",
                "KC_MISSION_CONTROL": "%%nf-md-application_settings;",
                "KC_MCTL": "@@KC_MISSION_CONTROL;",
                "KC_LAUNCHPAD": "%%nf-md-apps_box;",
                "KC_LPAD": "@@KC_LAUNCHPAD;",
                # Number pad keys
                "KC_KP_SLASH": "/",
                "KC_PSLS": "@@KC_KP_SLASH;",
                "KC_KP_ASTERISK": "*",
                "KC_PAST": "@@KC_KP_ASTERISK;",
                "KC_KP_MINUS": "-",
                "KC_PMNS": "@@KC_KP_MINUS;",
                "KC_KP_PLUS": "+",
                "KC_PPLS": "@@KC_KP_PLUS;",
                "KC_KP_ENTER": "%%nf-md-keyboard_return;",
                "KC_PENT": "@@KC_KP_ENTER;",
                "KC_KP_DOT": ".",
                "KC_PDOT": "@@KC_KP_DOT;",
                "KC_KP_EQUAL": "=",
                "KC_PEQL": "@@KC_KP_EQUAL;",
                "KC_KP_COMMA": ",",
                "KC_PCMM": "@@KC_KP_COMMA;",
                "KC_KP_EQUAL_AS400": "@@KC_KP_EQUAL;",
                # Special keys
                "KC_NO": "",
                "XXXXXXX": "@@KC_NO;",
                "KC_TRANSPARENT": "",
                "KC_TRNS": "@@KC_TRANSPARENT;",
                "_______": "@@KC_TRANSPARENT;",
                # Shifted symbols
                "KC_TILDE": "~",
                "KC_TILD": "@@KC_TILDE;",
                "KC_EXCLAIM": "!",
                "KC_EXLM": "@@KC_EXCLAIM;",
                "KC_AT": "@",
                "KC_HASH": "#",
                "KC_DOLLAR": "$",
                "KC_DLR": "@@KC_DOLLAR;",
                "KC_PERCENT": "%",
                "KC_PERC": "@@KC_PERCENT;",
                "KC_CIRCUMFLEX": "^",
                "KC_CIRC": "@@KC_CIRCUMFLEX;",
                "KC_AMPERSAND": "&",
                "KC_AMPR": "@@KC_AMPERSAND;",
                "KC_ASTERISK": "*",
                "KC_ASTR": "@@KC_ASTERISK;",
                "KC_LEFT_PAREN": "(",
                "KC_LPRN": "@@KC_LEFT_PAREN;",
                "KC_RIGHT_PAREN": ")",
                "KC_RPRN": "@@KC_RIGHT_PAREN;",
                "KC_UNDERSCORE": "_",
                "KC_UNDS": "@@KC_UNDERSCORE;",
                "KC_PLUS": "+",
                "KC_LEFT_CURLY_BRACE": "{",
                "KC_LCBR": "@@KC_LEFT_CURLY_BRACE;",
                "KC_RIGHT_CURLY_BRACE": "}",
                "KC_RCBR": "@@KC_RIGHT_CURLY_BRACE;",
                "KC_PIPE": "|",
                "KC_COLON": ":",
                "KC_COLN": "@@KC_COLON;",
                "KC_DOUBLE_QUOTE": '"',
                "KC_DQUO": "@@KC_DOUBLE_QUOTE;",
                "KC_DQT": "@@KC_DOUBLE_QUOTE;",
                "KC_LEFT_ANGLE_BRACKET": "<",
                "KC_LABK": "@@KC_LEFT_ANGLE_BRACKET;",
                "KC_LT": "@@KC_LEFT_ANGLE_BRACKET;",
                "KC_RIGHT_ANGLE_BRACKET": ">",
                "KC_RABK": "@@KC_RIGHT_ANGLE_BRACKET;",
                "KC_GT": "@@KC_RIGHT_ANGLE_BRACKET;",
                "KC_QUESTION": "?",
                "KC_QUES": "@@KC_QUESTION;",
                # QMK Quantum keycodes
                "QK_CAPS_WORD_TOGGLE": "%%nf-md-apple_keyboard_caps;",
                "CW_TOGG": "%%nf-md-apple_keyboard_caps;",
                "QK_REPEAT_KEY": "%%nf-fa-repeat; REP",
                "QK_REP": "%%nf-fa-repeat; REP",
                # Svalboard keys
                "SV_LEFT_DPI_INC": "L %%nf-md-mouse_move_up;",
                "SV_LEFT_DPI_DEC": "L %%nf-md-mouse_move_down;",
                "SV_RIGHT_DPI_INC": "R %%nf-md-mouse_move_up;",
                "SV_RIGHT_DPI_DEC": "R %%nf-md-mouse_move_down;",
                "SV_LEFT_SCROLL_TOGGLE": "L %%nf-md-mouse_move_vertical;%%nf-md-toggle_switch_off_outline;",
                "SV_RIGHT_SCROLL_TOGGLE": "R %%nf-md-mouse_move_vertical;%%nf-md-toggle_switch_off_outline;",
                "SV_AXIS_SCROLL_LOCK": "%%nf-md-mouse_move_vertical;%%nf-oct-lock;",
                "SV_OUTPUT_STATUS": "%%nf-oct-log;",
                "SV_SNIPER_2": "%%nf-md-crosshairs;2",
                "SV_SNIPER_3": "%%nf-md-crosshairs;3",
                "SV_SNIPER_5": "%%nf-md-crosshairs;5",
            }
        )

        return mapping

    def _generate_labels(self, layer_keycodes: List[str]) -> List[List[str]]:
        """
        Generate labels array for a layer by splitting 60-key array into 10 clusters.

        Key matrix layout (60 keys):
        - indices 0-5: FR1 (Right finger 1)
        - indices 6-11: FR2
        - indices 12-17: FR3
        - indices 18-23: FR4
        - indices 24-29: FL1 (Left finger 1)
        - indices 30-35: FL2
        - indices 36-41: FL3
        - indices 42-47: FL4
        - indices 48-53: TCR (Thumb cluster right)
        - indices 54-59: TCL (Thumb cluster left)

        Args:
            layer_keycodes: List of 60 keycodes for this layer
            mapping: Keycode mapping dictionary

        Returns:
            List of 10 sub-arrays, each containing 6 translated labels
        """
        if len(layer_keycodes) != 60:
            self._ctx.warn(f"Warning: Expected 60 keys, got {len(layer_keycodes)}")

        labels = []

        # Split into 10 clusters of 6 keys each
        for cluster_idx in range(10):
            start_idx = cluster_idx * 6
            end_idx = start_idx + 6
            cluster_keycodes = layer_keycodes[start_idx:end_idx]

            # Translate each keycode in the cluster
            cluster_labels = [self._translate_keycode(kc) for kc in cluster_keycodes]
            labels.append(cluster_labels)

        return labels

    def _translate_keycode(self, keycode: str, visited: Optional[set] = None) -> str:
        """
        Translate a single keycode to display label.

        Handles:
        - Direct mapping lookups
        - Key label references (@@KEYCODE;...)
        - Modifier combinations like S(KC_TAB)
        - Layer toggle keys like MO(_MED)
        - Nested modifiers like C(G(KC_DOWN))

        Args:
            keycode: The QMK keycode to translate
            mapping: The keycode mapping dictionary
            visited: Set of visited keycodes (for circular reference detection)

        Returns:
            Translated display label
        """
        # Initialize visited set for recursion tracking
        if visited is None:
            visited = set()

        # Check for circular references
        if keycode in visited:
            print(
                f"Warning: Circular reference detected for keycode '{keycode}'",
                file=sys.stderr,
            )
            return keycode  # Return keycode as-is to break the cycle

        visited.add(keycode)

        # Check custom mapping first
        if keycode in self.keymap_labels:
            label = self.keymap_labels[keycode]

            # Check if label contains any references (@@KEYCODE;)
            if "@@" in label:
                # Find and replace all references in the label
                def replace_reference(match):
                    ref_keycode = match.group(1)
                    # Recursively resolve the referenced keycode
                    return self._translate_keycode(ref_keycode, visited)

                # Replace all occurrences of @@KEYCODE;
                resolved_label = re.sub(r"@@([^;]+);", replace_reference, label)
                return resolved_label

            return label

        # Handle MO(layer) keys
        mo_match = re.match(r"MO\(([^)]+)\)", keycode)
        if mo_match:
            layer_name = mo_match.group(1)
            # Remove leading underscore if present
            layer_name = layer_name.lstrip("_")
            return layer_name

        # Handle modifier combinations
        # Pattern: MOD(content) where MOD is S, C, A, or G
        mod_match = re.match(r"([SCAG])\((.+)\)", keycode)
        if mod_match:
            modifier = mod_match.group(1)
            inner_content = mod_match.group(2)

            # Map modifier to icon
            mod_icons = {
                "S": self._translate_keycode("KC_LEFT_SHIFT", visited),
                "C": self._translate_keycode("KC_LEFT_CTRL", visited),
                "A": self._translate_keycode("KC_LEFT_ALT", visited),
                "G": self._translate_keycode("KC_LEFT_GUI", visited),
            }

            # Recursively translate inner content
            inner_label = self._translate_keycode(inner_content, visited)

            # Combine modifier icon with inner label
            if inner_label:
                return f"{mod_icons[modifier]} {inner_label}"
            else:
                return mod_icons[modifier]

        # Fallback: return keycode as-is
        return keycode

    def _detect_thumb_cluster_toggles(
        self,
        layer_keycodes: List[str],
        start_idx: int,
        key_layer_toggles: Dict[str, int],
        layer_ids: Dict[str, int],
        thumb_to_finger_map: Dict[int, int],
    ) -> List[Optional[int]]:
        """
        Helper function to detect layer toggles for a single thumb cluster.

        Args:
            layer_keycodes: List of all keycodes for the layer
            start_idx: Starting index of the thumb cluster (48 for TCR, 54 for TCL)
            key_layer_toggles: Mapping from keycode to layer index
            layer_ids: Mapping from layer name to layer index
            thumb_to_finger_map: Mapping from thumb position to finger position

        Returns:
            List of 6 values (one per finger position), either layer index or None
        """
        toggles: List[Optional[int]] = [None] * 6

        for local_idx in range(6):
            global_idx = start_idx + local_idx
            keycode = layer_keycodes[global_idx]

            layer_num = None

            # First check keyLayerToggles mapping
            if keycode in key_layer_toggles:
                layer_num = key_layer_toggles[keycode]
            else:
                # Fall back to MO() key detection
                mo_match = re.match(r"MO\(([^)]+)\)", keycode)
                if mo_match:
                    layer_ref = mo_match.group(1)
                    # Extract layer number (handle both numeric and _NAME formats)
                    if layer_ref.startswith("_"):
                        layer_num = layer_ids.get(layer_ref, None)
                    else:
                        layer_num = int(layer_ref)

            # Map thumb position to finger position for layerToggles
            if local_idx in thumb_to_finger_map and layer_num is not None:
                finger_pos = thumb_to_finger_map[local_idx]
                toggles[finger_pos] = layer_num

        return toggles

    def _detect_layer_toggles(
        self,
        layer_keycodes: List[str],
        key_layer_toggles: Dict[str, int],
        layer_ids: Dict[str, int],
    ) -> List[List[Optional[int]]]:
        """
        Detect layer toggle keys and generate layerToggles structure.

        Checks keyLayerToggles mapping first, then falls back to MO() key detection.
        Layer toggles are typically on thumb cluster keys, but we check all positions.
        The structure is [right_side_toggles, left_side_toggles], where each side
        has 6 values corresponding to finger cluster key positions.

        Args:
            layer_keycodes: List of 60 keycodes for this layer
            key_layer_toggles: Mapping from keycode to layer index (from keymap-config.yaml)
            layer_ids: Mapping from layer name to layer index (from keymap-config.yaml)

        Returns:
            Two arrays: [[right_toggles], [left_toggles]]
            Each array has 6 values (one per finger position), either layer index or None
        """
        # Check thumb clusters for layer toggle keys
        # TCR (indices 48-53): [Down, Pad, Up, Nail, Knuckle, Double-Down]
        # TCL (indices 54-59): [Down, Pad, Up, Nail, Knuckle, Double-Down]

        # For thumb cluster Pad/Nail/Knuckle keys (positions 1, 3, 4)
        # Map them to finger cluster positions (used in layerToggles)
        thumb_to_finger_map = {
            1: 1,  # Pad -> North
            3: 3,  # Nail -> South
            4: 4,  # Knuckle -> West
        }

        # Check right thumb cluster (TCR, indices 48-53)
        right_toggles = self._detect_thumb_cluster_toggles(
            layer_keycodes, 48, key_layer_toggles, layer_ids, thumb_to_finger_map
        )

        # Check left thumb cluster (TCL, indices 54-59)
        left_toggles = self._detect_thumb_cluster_toggles(
            layer_keycodes, 54, key_layer_toggles, layer_ids, thumb_to_finger_map
        )

        return [right_toggles, left_toggles]

    def _resolve_color(self, color_input: str) -> str:
        """
        Resolve a color input to a hex color.

        QMK color names are already darkened for better text readability.
        Hex colors are returned as-is.
        If a named color cannot be resolved, fallback to black.

        Args:
            color_input: Either a hex color string or a QMK color name
            qmk_colors: Dictionary of QMK color names to (already darkened) hex colors

        Returns:
            Hex color string
        """
        qmk_colors = self._ctx.qmk_colors

        # Check if it's already a hex color
        if color_input.startswith("#"):
            return color_input

        # Try to resolve as a QMK color name (case-insensitive)
        # Colors are already darkened when loaded from color.h
        color_name = color_input.lower()
        if color_name in qmk_colors:
            return qmk_colors[color_name]

        # If not found, assume it's a hex color without the # prefix (#RRGGBB or #RGB)
        if len(color_input) == 6 or len(color_input) == 3:
            return f"#{color_input}"

        # Fallback: named color not found, return black
        print(
            f"Warning: Could not resolve color '{color_input}', using black",
            file=sys.stderr,
        )
        return "#000000"

    def _generate_color_gradient(
        self, base_color: str, base_index: int = 2
    ) -> List[str]:
        """
        Generate a 6-color gradient from a base color.

        The base_color will be positioned at base_index (default: 2),
        with darker shades before and lighter shades after.

        Args:
            base_color: Hex color string (e.g., "#347156")
            base_index: Index where the base color should appear (0-5, default: 2)

        Returns:
            List of 6 hex color strings forming a gradient
        """
        # Convert base color to RGB then HLS
        red, green, blue = str_to_rgb(base_color)

        hue, lightness, saturation = colorsys.rgb_to_hls(red, green, blue)

        # Generate lightness values for 6 colors
        # We'll create a gradient where the base_index has the original lightness
        # Indices before are darker, indices after are lighter

        # Calculate lightness multipliers for each position relative to base
        # For base_index=2: [0.15, 0.50, 1.0, 1.40, 1.85, 2.30]
        # This creates a smooth progression from very dark to very light

        num_colors = 6
        lightness_values = []

        # Calculate the range we need to cover
        # Darker colors: reduce lightness
        # Lighter colors: increase lightness
        for i in range(num_colors):
            if i < base_index:
                # Darker colors - interpolate from very dark to base
                # Progress from 0 (darkest) to base_index (base)
                progress = i / base_index if base_index > 0 else 0
                # Map to lightness range [0.15*l, l]
                target_l = lightness * (0.15 + 0.85 * progress)
            elif i == base_index:
                # Base color - keep original lightness
                target_l = lightness
            else:
                # Lighter colors - interpolate from base to very light
                # Progress from base_index (base) to num_colors-1 (lightest)
                remaining = num_colors - 1 - base_index
                progress = (i - base_index) / remaining if remaining > 0 else 0
                # Map to lightness range [l, min(0.95, l * 2.3)]
                max_lightness = min(0.95, lightness * 2.3)
                target_l = lightness + (max_lightness - lightness) * progress

            lightness_values.append(min(1.0, target_l))

        # Generate colors with adjusted lightness
        gradient = []
        for target_l in lightness_values:
            # Slightly reduce saturation for very light colors to avoid oversaturation
            adjusted_s = saturation
            if target_l > 0.7:
                saturation_factor = 1.0 - (target_l - 0.7) * 0.5
                adjusted_s = saturation * saturation_factor

            r_new, g_new, b_new = colorsys.hls_to_rgb(hue, target_l, adjusted_s)
            gradient.append(hex_str(r_new, g_new, b_new))

        return gradient


def main():
    """
    Entry point: Load qmk.json, run qmk c2json, and generate keymap.yaml.
    """
    # Parse command-line arguments
    parser = argparse.ArgumentParser(
        description="Generate keymap.yaml from QMK c2json output and keymap-config.yaml"
    )
    parser.add_argument(
        "-c",
        "--color-header-path",
        type=Path,
        help="Path to the QMK color.h file (e.g., /path/to/qmk/quantum/color.h). If not provided, will query QMK CLI for QMK home.",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Print informational messages during execution",
    )
    args = parser.parse_args()

    # Initialize context - handles all path discovery and configuration loading
    ctx = QmkContext(verbose=args.verbose, color_header_path=args.color_header_path)

    # Initialize generator
    generator = KeymapGenerator(ctx)
    generator.make_keymap_images(ctx.project_root / "docs")

    ctx.info("Done!")


if __name__ == "__main__":
    main()
